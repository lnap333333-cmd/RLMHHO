# RL-Chaotic-HHO编码解码计算过程详解

## 1. 编码向量结构

### 1.1 完整编码向量（24维，6工件×4层）
```
染色体 = [3, 1, 6, 2, 5, 4,          // 工件优先级层
          0, 2, 1, 0, 1, 2,          // 工厂分配层  
          0.8, 0.3, 0.7, 0.2, 0.9, 0.4,  // 机器选择层
          0.6, 0.1, 0.8, 0.4, 0.7, 0.3]  // 时间权重层
```

### 1.2 分层解释
```
位置:  0  1  2  3  4  5  6  7  8  9 10 11 12  13  14  15  16  17  18  19  20  21  22  23
工件: J1 J2 J3 J4 J5 J6 J1 J2 J3 J4 J5 J6 J1  J2  J3  J4  J5  J6  J1  J2  J3  J4  J5  J6
层次: |---优先级层---|---工厂分配层---|-----机器选择层-----|-----时间权重层-----|
```

## 2. 解码步骤详细计算

### 2.1 步骤1：工件优先级排序

**输入优先级向量**: [3, 1, 6, 2, 5, 4]

**排序过程**:
```
J1的优先级: 3  →  排序位置: 3
J2的优先级: 1  →  排序位置: 1 (最高优先级)
J3的优先级: 6  →  排序位置: 6 (最低优先级)  
J4的优先级: 2  →  排序位置: 2
J5的优先级: 5  →  排序位置: 5
J6的优先级: 4  →  排序位置: 4
```

**优先级排序结果**: [J2, J4, J1, J6, J5, J3]

### 2.2 步骤2：工厂分配计算

**输入工厂分配向量**: [0, 2, 1, 0, 1, 2]

**分配计算过程**:
```python
def decode_factory_assignment(assignment_vector, n_factories):
    factory_assignment = []
    for i, value in enumerate(assignment_vector):
        # 边界处理，确保工厂编号在有效范围内
        factory_id = min(max(0, int(value)), n_factories - 1)
        factory_assignment.append(factory_id)
    return factory_assignment

# 计算结果
J1 → 工厂 min(max(0, 0), 2) = 0  →  F0
J2 → 工厂 min(max(0, 2), 2) = 2  →  F2  
J3 → 工厂 min(max(0, 1), 2) = 1  →  F1
J4 → 工厂 min(max(0, 0), 2) = 0  →  F0
J5 → 工厂 min(max(0, 1), 2) = 1  →  F1
J6 → 工厂 min(max(0, 2), 2) = 2  →  F2
```

**各工厂工件分配**:
```
工厂F0: [J1, J4] → 按优先级排序 → [J4(优先级2), J1(优先级3)]
工厂F1: [J3, J5] → 按优先级排序 → [J5(优先级5), J3(优先级6)]  
工厂F2: [J2, J6] → 按优先级排序 → [J2(优先级1), J6(优先级4)]
```

### 2.3 步骤3：机器选择计算

**输入机器选择向量**: [0.8, 0.3, 0.7, 0.2, 0.9, 0.4]

**工厂机器配置**:
```
工厂F0: [2, 2, 3] (阶段0:2台, 阶段1:2台, 阶段2:3台)
工厂F1: [3, 1, 2] (阶段0:3台, 阶段1:1台, 阶段2:2台)
工厂F2: [1, 3, 2] (阶段0:1台, 阶段1:3台, 阶段2:2台)
```

**机器选择计算函数**:
```python
def select_machine(selection_value, n_machines_in_stage):
    # 使用取整函数将连续值映射到离散机器编号
    machine_index = min(int(selection_value * n_machines_in_stage), n_machines_in_stage - 1)
    return machine_index
```

**详细计算过程**:

#### 工厂F0的机器选择:
**J4 (选择值: 0.2)**:
```
阶段0: select_machine(0.2, 2) = min(int(0.2×2), 1) = min(0, 1) = 0 → M0
阶段1: select_machine(0.2, 2) = min(int(0.2×2), 1) = min(0, 1) = 0 → M0
阶段2: select_machine(0.2, 3) = min(int(0.2×3), 2) = min(0, 2) = 0 → M0
```

**J1 (选择值: 0.8)**:
```
阶段0: select_machine(0.8, 2) = min(int(0.8×2), 1) = min(1, 1) = 1 → M1
阶段1: select_machine(0.8, 2) = min(int(0.8×2), 1) = min(1, 1) = 1 → M1  
阶段2: select_machine(0.8, 3) = min(int(0.8×3), 2) = min(2, 2) = 2 → M2
```

#### 工厂F1的机器选择:
**J5 (选择值: 0.9)**:
```
阶段0: select_machine(0.9, 3) = min(int(0.9×3), 2) = min(2, 2) = 2 → M2
阶段1: select_machine(0.9, 1) = min(int(0.9×1), 0) = min(0, 0) = 0 → M0
阶段2: select_machine(0.9, 2) = min(int(0.9×2), 1) = min(1, 1) = 1 → M1
```

**J3 (选择值: 0.7)**:
```
阶段0: select_machine(0.7, 3) = min(int(0.7×3), 2) = min(2, 2) = 2 → M2
阶段1: select_machine(0.7, 1) = min(int(0.7×1), 0) = min(0, 0) = 0 → M0
阶段2: select_machine(0.7, 2) = min(int(0.7×2), 1) = min(1, 1) = 1 → M1
```

#### 工厂F2的机器选择:
**J2 (选择值: 0.3)**:
```
阶段0: select_machine(0.3, 1) = min(int(0.3×1), 0) = min(0, 0) = 0 → M0
阶段1: select_machine(0.3, 3) = min(int(0.3×3), 2) = min(0, 2) = 0 → M0
阶段2: select_machine(0.3, 2) = min(int(0.3×2), 1) = min(0, 1) = 0 → M0
```

**J6 (选择值: 0.4)**:
```
阶段0: select_machine(0.4, 1) = min(int(0.4×1), 0) = min(0, 0) = 0 → M0
阶段1: select_machine(0.4, 3) = min(int(0.4×3), 2) = min(1, 2) = 1 → M1
阶段2: select_machine(0.4, 2) = min(int(0.4×2), 1) = min(0, 1) = 0 → M0
```

### 2.4 步骤4：加工时间调整计算

**输入时间权重向量**: [0.6, 0.1, 0.8, 0.4, 0.7, 0.3]

**基础加工时间矩阵** (假设):
```
       阶段0  阶段1  阶段2
J1:    [8,    6,    10]
J2:    [5,    7,    8 ]
J3:    [6,    4,    9 ]
J4:    [7,    5,    6 ]
J5:    [9,    8,    7 ]
J6:    [4,    6,    5 ]
```

**时间调整计算函数**:
```python
def adjust_processing_time(base_time, weight):
    # 调整系数范围: [0.8, 1.2]
    adjustment_factor = 0.8 + 0.4 * weight
    return base_time * adjustment_factor
```

**详细计算过程**:
```
J1 (权重=0.6): 系数 = 0.8 + 0.4×0.6 = 1.04
  阶段0: 8 × 1.04 = 8.32 ≈ 8.3
  阶段1: 6 × 1.04 = 6.24 ≈ 6.2  
  阶段2: 10 × 1.04 = 10.4

J2 (权重=0.1): 系数 = 0.8 + 0.4×0.1 = 0.84
  阶段0: 5 × 0.84 = 4.2
  阶段1: 7 × 0.84 = 5.88 ≈ 5.9
  阶段2: 8 × 0.84 = 6.72 ≈ 6.7

J3 (权重=0.8): 系数 = 0.8 + 0.4×0.8 = 1.12  
  阶段0: 6 × 1.12 = 6.72 ≈ 6.7
  阶段1: 4 × 1.12 = 4.48 ≈ 4.5
  阶段2: 9 × 1.12 = 10.08 ≈ 10.1

J4 (权重=0.4): 系数 = 0.8 + 0.4×0.4 = 0.96
  阶段0: 7 × 0.96 = 6.72 ≈ 6.7
  阶段1: 5 × 0.96 = 4.8
  阶段2: 6 × 0.96 = 5.76 ≈ 5.8

J5 (权重=0.7): 系数 = 0.8 + 0.4×0.7 = 1.08
  阶段0: 9 × 1.08 = 9.72 ≈ 9.7
  阶段1: 8 × 1.08 = 8.64 ≈ 8.6
  阶段2: 7 × 1.08 = 7.56 ≈ 7.6

J6 (权重=0.3): 系数 = 0.8 + 0.4×0.3 = 0.92
  阶段0: 4 × 0.92 = 3.68 ≈ 3.7
  阶段1: 6 × 0.92 = 5.52 ≈ 5.5
  阶段2: 5 × 0.92 = 4.6
```

## 3. 调度时间计算

### 3.1 工厂F0调度时间计算
**工件序列**: J4 → J1

**J4调度** (机器路径: M0→M0→M0):
```
阶段0: 开始时间=0,   完成时间=0+6.7=6.7
阶段1: 开始时间=6.7, 完成时间=6.7+4.8=11.5  
阶段2: 开始时间=11.5, 完成时间=11.5+5.8=17.3
```

**J1调度** (机器路径: M1→M1→M2):
```
阶段0: 开始时间=0,    完成时间=0+8.3=8.3    (M1可用)
阶段1: 开始时间=8.3,  完成时间=8.3+6.2=14.5  (M1可用)
阶段2: 开始时间=14.5, 完成时间=14.5+10.4=24.9 (M2可用)
```

### 3.2 目标函数计算

**完工时间 (Makespan)**:
```
工厂F0最大完工时间: max(17.3, 24.9) = 24.9
工厂F1最大完工时间: (类似计算)
工厂F2最大完工时间: (类似计算)

总完工时间 = max(所有工厂完工时间)
```

**总拖期 (Total Tardiness)**:
```python
def calculate_tardiness(completion_time, due_date):
    return max(0, completion_time - due_date)

总拖期 = sum(calculate_tardiness(工件i完工时间, 工件i交货期) for i in 所有工件)
```

## 4. 编码解码复杂度分析

### 4.1 时间复杂度
- **编码**: O(1) - 直接赋值
- **优先级排序**: O(n log n) - 其中n为工件数
- **工厂分配**: O(n)
- **机器选择**: O(n × s) - 其中s为阶段数
- **调度计算**: O(n × s × m) - 其中m为平均机器数

**总复杂度**: O(n log n + n × s × m)

### 4.2 空间复杂度
- **编码向量**: O(4n) = O(n)
- **调度矩阵**: O(f × s × m) - 其中f为工厂数
- **中间结果**: O(n)

**总复杂度**: O(n + f × s × m)

---

*本文档提供了RL-Chaotic-HHO算法编码解码的详细计算过程，包含所有数值计算步骤和复杂度分析。* 