# MO-DHFSP编码解码具体示例

## 1. 问题实例设置

### 1.1 基本参数
- 工件数量：6个工件(J1-J6)
- 工厂数量：3个工厂(F1-F3)
- 每个工序2台并行机器
- 每个工件3道工序

### 1.2 初始数据
工件加工时间矩阵（每道工序在不同机器上的加工时间）：
```
工件1：[[4,5], [3,4], [5,6]]  // [工序1机器1,工序1机器2], [工序2机器1,工序2机器2], [工序3机器1,工序3机器2]
工件2：[[3,4], [4,5], [4,5]]
工件3：[[5,6], [3,4], [4,5]]
工件4：[[4,5], [5,6], [3,4]]
工件5：[[3,4], [4,5], [5,6]]
工件6：[[5,6], [4,5], [4,5]]
```

## 2. 编码示例

### 2.1 染色体结构
```
工件向量(X1)：[0.2, 0.4, 0.8, 1.1, 1.4, 1.8]  // 表示工件优先级
工厂向量(X2)：[1,   3,   2,   1,   2,   3  ]  // 表示工厂分配
```

### 2.2 机器选择编码
```
机器选择向量(AM)：[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]  // 每个工序选择的机器编号
```

## 3. 解码过程

### 3.1 工厂分配解码
根据工厂向量X2直接得到工件分配：
```
工厂1：{J1, J4}     // X2中值为1的位置对应的工件
工厂2：{J3, J5}     // X2中值为2的位置对应的工件
工厂3：{J2, J6}     // X2中值为3的位置对应的工件
```

### 3.2 工序排序解码
根据工件向量X1的值大小确定优先级（值越小优先级越高）：

工厂1内部排序：
```
J1(0.2) → J4(1.1)  // 0.2 < 1.1，所以J1先加工
```

工厂2内部排序：
```
J3(0.8) → J5(1.4)  // 0.8 < 1.4，所以J3先加工
```

工厂3内部排序：
```
J2(0.4) → J6(1.8)  // 0.4 < 1.8，所以J2先加工
```

### 3.3 机器分配解码
以工厂1为例：
```
J1的三道工序：
- 工序1：选择机器1 (AM[0]=1)
- 工序2：选择机器2 (AM[1]=2)
- 工序3：选择机器1 (AM[2]=1)

J4的三道工序：
- 工序1：选择机器2 (AM[3]=2)
- 工序2：选择机器1 (AM[4]=1)
- 工序3：选择机器2 (AM[5]=2)
```

## 4. 具体调度生成

### 4.1 工厂1的调度
工件J1：
```
工序1：机器1，开始时间=0，    完工时间=4
工序2：机器2，开始时间=4，    完工时间=8
工序3：机器1，开始时间=8，    完工时间=13
```

工件J4：
```
工序1：机器2，开始时间=0，    完工时间=5
工序2：机器1，开始时间=5，    完工时间=10
工序3：机器2，开始时间=10，   完工时间=14
```

### 4.2 工厂2的调度
工件J3：
```
工序1：机器1，开始时间=0，    完工时间=5
工序2：机器2，开始时间=5，    完工时间=9
工序3：机器1，开始时间=9，    完工时间=13
```

工件J5：
```
工序1：机器2，开始时间=0，    完工时间=4
工序2：机器1，开始时间=4，    完工时间=8
工序3：机器2，开始时间=9，    完工时间=15
```

### 4.3 工厂3的调度
工件J2：
```
工序1：机器1，开始时间=0，    完工时间=3
工序2：机器2，开始时间=3，    完工时间=8
工序3：机器1，开始时间=8，    完工时间=12
```

工件J6：
```
工序1：机器2，开始时间=0，    完工时间=6
工序2：机器1，开始时间=6，    完工时间=10
工序3：机器2，开始时间=10，   完工时间=15
```

## 5. 目标值计算

### 5.1 完工时间(Makespan)
```
工厂1完工时间：max(13, 14) = 14
工厂2完工时间：max(13, 15) = 15
工厂3完工时间：max(12, 15) = 15

总完工时间 = max(14, 15, 15) = 15
```

### 5.2 总拖期(Total Tardiness)
假设每个工件的交付期限为：
```
[J1:10, J2:11, J3:12, J4:13, J5:14, J6:13]

J1拖期：max(0, 13-10) = 3
J2拖期：max(0, 12-11) = 1
J3拖期：max(0, 13-12) = 1
J4拖期：max(0, 14-13) = 1
J5拖期：max(0, 15-14) = 1
J6拖期：max(0, 15-13) = 2

总拖期 = 3 + 1 + 1 + 1 + 1 + 2 = 9
```

## 6. 甘特图表示

```
工厂1：
机器1：[J1-1][---][J4-2][---]
机器2：[J4-1][J1-2][J4-3]

工厂2：
机器1：[J3-1][J5-2][J3-3]
机器2：[J5-1][J3-2][J5-3]

工厂3：
机器1：[J2-1][--][J6-2][J2-3]
机器2：[J6-1][J2-2][J6-3]
```
注：[Jx-y]表示工件x的第y道工序，[-]表示空闲时间

## 7. 编码特点分析

### 7.1 优点
1. 编码直观：
   - 工厂分配明确
   - 优先级关系清晰
   - 机器选择直接

2. 解码高效：
   - 工厂分配无需计算
   - 排序规则简单
   - 机器分配直接映射

3. 约束处理方便：
   - 工序前后关系自动满足
   - 机器容量约束易于处理
   - 工厂负载自动平衡

### 7.2 局限性
1. 解空间大小：
   - 3^6 种工厂分配可能
   - 6! 种工序排序可能
   - 2^18 种机器选择可能

2. 搜索难度：
   - 需要同时优化多个向量
   - 局部最优点多
   - 参数调整复杂 