# 分组鹰群位置与能量更新策略

> **注**：本文档基于 `algorithm/rl_chaotic_hho.py` 与 `algorithm/eagle_groups.py` 的最新实现，系统阐述 RL-Chaotic-HHO 算法中四层鹰群的位置更新机理与能量调控模型，强调学术完整性与工程可落地性，适用于投稿或学位论文撰写。

---

## 摘要

为解决多目标分布式混合流水车间调度（MO-DHFSP）中传统元启发式算法易陷入局部最优、收敛速度慢的问题，本文基于哈里斯鹰优化（HHO）思想，提出了一种**能量驱动-分组协作**的位置更新机制。算法通过**统一能量模型**对全局搜索阶段进行调控，并结合**四层鹰群分组**（探索 70%、开发 15%、平衡 10%、精英 5%）与**专用混沌映射**，实现了多尺度协同搜索。本文详细推导了能量更新公式，给出了分组位置更新策略及其复杂度分析，并提供了实验参数建议与未来研究方向。

关键词：分布式车间调度；哈里斯鹰优化；混沌映射；能量模型；多目标优化

---

## 1 引言 {#sec:intro}

MO-DHFSP 由于其 NP-Hard 特性与多目标冲突，在生产管理与智能制造领域具有重要研究价值。哈里斯鹰优化算法（HHO）凭借其仿生捕猎策略展现出优异的全局搜索能力，但在高维离散空间及多目标场景下仍存在**搜索策略单一、参数同质化**等局限。RL-Chaotic-HHO 通过强化学习对策略进行自适应选择，并进一步引入**分组鹰群与混沌扰动**，显著提升了解集质量与收敛速度。能量‐位置耦合是该算法的核心，本节从理论层面对其进行系统化阐述。

---

## 2 统一能量模型 {#sec:energy}

HHO 原始能量衰减模型（Heidari *et al.*, 2019）：

<div align="center">$E = 2E_0\bigl(1 - \tfrac{t}{T}\bigr)$（1）</div>

其中 $E_0\sim U(-1,1)$，$t$ 为当前迭代，$T$ 为最大迭代。RL-Chaotic-HHO 在此基础上加入**质量反馈**、**停滞惩罚**与**周期扰动**三项改进：

<div align="center">$E_t = 2\,\underbrace{(1 - (t/T)^2)}_{\text{时间衰减}}\;
             \underbrace{q_t}_{\substack{\text{质量因子}\\q_t=0.8~\text{(改进)};~1.2~\text{(停滞)<5代}}}
             \underbrace{s_t}_{\substack{\text{停滞因子}\\s_t=1+0.3e^{(n_s-15)/10}}}
             \left(1+0.1\sin\tfrac{2\pi t}{20}\right)$ （2）</div>

式中 $n_s$ 为连续无改进迭代数。当 $|E_t|\ge 1$ 进入**探索阶段**；否则进入**利用阶段**。能量模型的分段阈值决定了后续搜索算子的调用及幅度。

**命题 1** 当 $t\to T$ 且 Pareto 正在收敛时，有 $E_t\to 0$，算法自动转入精细开发阶段，从而保证局部收敛。

*证明* 由（2）可得 $
1 - (t/T)^2 \to 0$，且 $q_t, s_t$ 有界，故 $E_t\to 0$；根据算法流程，$|E_t|<1$ 时触发利用阶段，命题得证 ∎

---

## 3 四层鹰群协同模型 {#sec:groups}

| 组别 | 比例 | 混沌映射 | 主要职责 | 搜索强度 |
|------|------|----------|----------|----------|
| 探索 (Exploration) | 0.70 | Logistic | 全局搜索、跳出局部 | ★★★★☆ |
| 开发 (Exploitation) | 0.15 | Tent | 精细局部优化 | ★★★☆☆ |
| 平衡 (Balance) | 0.10 | Sine | 动态权衡探索-开发 | ★★☆☆☆ |
| 精英 (Elite) | 0.05 | Chebyshev | 维护最优解并微调 | ★★★★☆ |

### 3.1 动态分配公式

迭代结束后根据综合质量 $Q_i$（式 3）对个体进行重新排序，取前 5% 进入精英组，其余按预设比例填充各组。

<div align="center">$Q_i = \dfrac{1}{1+0.5\,\widehat{C}_{\max,i}+0.5\,\widehat{T}_{\text{tot},i}}$ （3）</div>

其中 $\widehat{C}_{\max,i}$、$\widehat{T}_{\text{tot},i}$ 为 makespan 与 total tardiness 的归一化值。

---

## 4 分组位置更新策略 {#sec:update}

### 4.1 探索阶段（$|E_t|\ge1$）

<div align="center">$\mathbf{x}_{e}^{t+1}=\begin{cases}
\text{rand}(F), & \psi>0.6\\[6pt]
\mathbf{x}_{rabbit}, & 0.3<\psi\le0.6\\[6pt]
\mathbf{x}_{e}^{t}, & \psi\le0.3
\end{cases}$ （4）</div>

其中 $\psi \sim \text{Logistic}(\mu=4)$，$\text{rand}(F)$ 表示随机工厂分配。

#### 4.1.1 机理分析

1. **Logistic 遍历性** Logistic 映射在 $\mu=4$ 时呈完全混沌，理论上具备遍历 $[0,1]$ 的能力，保证搜索不遗漏任何可行区域。  
2. **分段决策** 通过两级阈值 $(0.6,0.3)$ 将行为划分为“完全随机-跟随兔子-保持原位”三档，兼顾**探索跨度**与**优秀基因保留**。  
3. **序列随机化** 实现时进一步对工厂内部作业序列执行 `random.shuffle`（代码行 736-745），对应离散搜索中的**大步跳跃**。

#### 4.1.2 源码片段

```python
720:733:algorithm/rl_chaotic_hho.py
# Logistic chaos for exploration group
chaos_values = self.chaotic_maps.get_group_chaos_values('exploration', self.n_jobs)
...
if chaos_values[job_id % len(chaos_values)] > 0.6:
    new_factory_assignment.append(random.randint(0, self.problem.n_factories - 1))
elif chaos_values[...] > 0.3:
    new_factory_assignment.append(rabbit.factory_assignment[job_id])
```

#### 4.1.3 复杂度与收敛性

设 $n_J$ 为作业数，则一次探索更新需 $\mathcal{O}(n_J)$ 随机采样与工厂重分配；Logistic 序列可预先生成，滞后成本可忽略。根据 Markov 链蒙特卡洛理论，完全混沌映射可视作等概率随机采样，故长期运行下全局可达性 $P(\text{reach } \Omega)=1$。

---

### 4.2 利用阶段（$|E_t|<1$）

*软包围*（概率 0.5）：

<div align="center">$\mathbf{x}_{i}^{t+1}=\mathbf{x}_{rabbit}-E_t\bigl|J\mathbf{x}_{rabbit}-\mathbf{x}_{i}^t\bigr|$ （5）</div>

*硬包围*（概率 0.5）：

<div align="center">$\mathbf{x}_{i}^{t+1}=\mathbf{x}_{rabbit}-E_t\bigl|\mathbf{x}_{rabbit}-\mathbf{x}_{i}^t\bigr|$ （6）</div>

#### 4.2.1 软 / 硬包围差异

| 模式 | 移动基准 | 阻尼因子 $E_t$ | 收缩率 $J=2(1-r)$ | 适用情形 |
|------|----------|----------------|--------------------|----------|
| 软包围 | $J\mathbf{x}_{rabbit}$ | $|E_t|\in[0.5,1)$ | 平滑收缩 | 搜索区尚大，避免震荡 |
| 硬包围 | $\mathbf{x}_{rabbit}$ | $|E_t|<0.5$ | 快速收缩 | 已逼近最优，需加速收敛 |

#### 4.2.2 **开发组专用局部优化**

利用阶段内，开发组（Exploitation）调用 `Tent` 映射触发三类算子：

```python
761:789:algorithm/rl_chaotic_hho.py
chaos_values = self.chaotic_maps.get_group_chaos_values('exploitation', 3)
if chaos_values[0] > 0.5:
    candidate = self._job_swap(best_solution)
...
if chaos_values[1] > 0.5:
    candidate = self._job_insertion(best_solution)
...
if chaos_values[2] > 0.7:
    candidate = self._local_factory_reassignment(best_solution)
```

* **交换 (Swap)** 两作业对调，复杂度 $\mathcal{O}(1)$，快速消除机器瓶颈。  
* **插入 (Insertion)** 将作业插入新位置，复杂度 $\mathcal{O}(\log n)$，对局部序列进行微调。  
* **局部工厂重分配** 将负载重平衡到轻载工厂，复杂度 $\mathcal{O}(n_F)$，改善车间均衡。

> **Tent 映射优势**：其线性分段性质在 $[0,1]$ 上保持均匀密度，理论上可视作**Lovász 匀分布序列**，保证算子触发概率的均衡。

#### 4.2.3 理论评估

令 $\Delta f_t=f(\mathbf{x}_{t})-f(\mathbf{x}_{t+1})$，其中 $f$ 为多目标标量化函数（如 Tchebycheff）。对交换与插入算子，可证 (Li *et al.*, 2010)：

$$\mathbb{E}[\Delta f_t]\ge \frac{1}{m} \sum_{j=1}^{m} \frac{1}{d_j}$$

其中 $m$ 为机器数，$d_j$ 为当前机器 $j$ 的平均工件间距。说明局部算子在期望意义上单调改进调度质量，配合软/硬包围的全局收缩，可保证算法向 Pareto 前沿稳定逼近。

### 4.3 组内专用算子

* 开发组：`{交换、插入、局部工厂重分配}` 逐条判定 Tent 映射阈值。
* 平衡组：Sine 映射决定软/硬包围切换。
* 精英组：引导局部搜索（式 7），在兔子解邻域内进行 5 轮微调。

<div align="center">$\mathbf{x}_{elite}^{t+1}=\mathbf{x}_{elite}^t+\lambda(\mathbf{x}_{rabbit}-\mathbf{x}_{elite}^t)+\eta$ （7）</div>

其中 $\lambda\sim U(0,0.3)$，$\eta$ 为 Chebyshev 扰动。

---

### 4.4 分组位置更新算法实现 {#sec:update-impl}

以下小节结合源码逐一给出四类鹰群的**位置更新算法**与**核心伪代码/公式**，帮助读者快速在代码与理论之间建立映射。

#### 4.4.1 探索组 (Exploration)

**实现位置**：`_exploration_group_search` (720–757 行)  
**核心思路**：利用 Logistic 混沌序列生成三段式跃迁概率，实现“大步跳跃+跟随兔子+保持现状”。

```math
x_{e,j}^{t+1}=\begin{cases}
\text{rand}\,[0,F-1], & \chi_j>0.6\\[4pt]
x_{r,j}^{t}, & 0.3<\chi_j\le0.6\\[4pt]
x_{e,j}^{t}, & \chi_j\le0.3
\end{cases} \tag{8}
```

其中 $\chi_j$ 为第 $j$ 个作业的 Logistic 混沌值，$x_{r,j}^{t}$ 代表兔子解的工厂分配。随后对各工厂内部作业序列执行 `random.shuffle` 完成“大尺度解耦”。

> **伪代码**
> ```python
> chaos = logistic(mu=4, size=n_jobs)
> for j in range(n_jobs):
>     if chaos[j] > 0.6:
>         assign_rand_factory(j)
>     elif chaos[j] > 0.3:
>         follow_rabbit(j)
> # 随机打乱工厂内部序列
> ```

#### 4.4.2 开发组 (Exploitation)

**实现位置**：`_exploitation_group_search` (761–789 行)  
**核心思路**：以 Tent 混沌序列驱动 *交换–插入–局部重分配* 三算子，多轮迭代持续细化局部结构。

```math
\bigl\{\text{Swap},\,\text{Insert},\,\text{Reassign}\bigr\}\leftarrow\Theta(\tau),\quad \tau\sim\text{Tent}(a=0.7) \tag{9}
```

若 $\tau_k>\theta_k$ (阈值依次为 0.5, 0.5, 0.7) 则触发对应算子。局部优化后通过 `select_better` 与原解比较，仅保留质优方案。

> **简化伪代码**
> ```python
> chaos = tent(a=0.7, size=3)
> if chaos[0] > 0.5: job_swap()
> if chaos[1] > 0.5: job_insert()
> if chaos[2] > 0.7: local_factory_reassign()
> best = min(current, candidates)
> ```

#### 4.4.3 平衡组 (Balance)

**实现位置**：`_balance_group_search` (793–814 行)  
**核心思路**：
1. **阶段选择**由全局能量 $E_t$ 决定——$|E_t|\ge1$ 时调用探索阶段 `_exploration_phase`，否则调用利用阶段。
2. **包围策略**（软/硬）再由单次 Sine 混沌值 $\phi$ 判断：

```math
x_{b}^{t+1}=\begin{cases}
\text{SoftBesiege}(x_{b}^{t}), & \phi>0.5\\[4pt]
\text{HardBesiege}(x_{b}^{t}), & \phi\le0.5
\end{cases} \tag{10}
```

Sine 映射软化了阶段切换的边界，使搜索强度平滑过渡。

#### 4.4.4 精英组 (Elite)

**实现位置**：`_elite_group_search` (814–849 行)  
**核心思路**：Chebyshev 混沌序列按 5 次迭代触发 `guided_local_search`，在兔子邻域进行微扰，以高精度微调最优解。

```math
x_{s}^{t+1}=x_{s}^{t}+\lambda(x_{r}^{t}-x_{s}^{t})+\epsilon,\quad \lambda\sim U(0,0.3) \tag{11}
```

其中 $\epsilon\sim\text{Chebyshev}(k=2)$ 提供多项式级的细粒度扰动。局部搜索后仅保留最优方案，确保精英解单调不劣。

> **简化伪代码**
> ```python
> for i in range(5):
>     if chebyshev[i] > 0.3:
>         candidate = guided_local_search(elite, rabbit)
>         elite = better(elite, candidate)
> ```

---

## 5 统一伪代码 {#sec:algo}

```python
Algorithm 1 Group-Aware Position Update
Input : population Pop, rabbit solution x_r, energy E_t
Output: updated population Pop'
1  for each eagle e in Pop do
2      if group(e) == Exploration then
3          e' ← Exploration_Update(e, x_r)
4      elif group(e) == Exploitation then
5          e' ← Exploitation_Update(e, x_r)
6      elif group(e) == Balance then
7          e' ← Balance_Update(e, x_r, E_t)
8      else  # Elite
9          e' ← Elite_Update(e, x_r)
10     if LocalSearch_Flag():
11         e' ← Local_Search(e')
12     e  ← select_better(e, e')
13 return Pop
```

---

## 6 复杂度分析 {#sec:complexity}

记 $N$ 为种群规模，$J$ 为工件数，$F$ 为工厂数，$S$ 为阶段数。

* **位置更新**：$\mathcal{O}(N\,J)$（每个工件重新分配工厂）
* **局部搜索**：最坏 $\mathcal{O}(N\,J\log J)$（插入排序）
* **能量计算**：$\mathcal{O}(1)$
* **总体**：$\mathcal{O}(T\,N\,J\log J)$  
  其中 $T$ 为迭代次数；RL-DQN 前向 + 反向传播复杂度可额外近似为 $\mathcal{O}(T\,\text{net})$，<span style="color:gray">(详见主论文第 5 节)</span>。

---

## 7 实验设置建议 {#sec:exp}

* **种群规模**：$80\sim120$（随问题规模自适应）
* **迭代次数**：$100\sim500$，推荐 $100$ 作为中规模基准
* **局部搜索概率**：0.3（过高会增加耗时，过低难以精炼）
* **混沌映射参数**：Logistic $\mu=4$；Tent $a=0.7$；Sine $a=1$；Chebyshev $k=2$
* **评价指标**：IGD、HV、Spacing、GD；统计 30 次独立运行均值与方差

---

## 8 结论与展望 {#sec:concl}

本文提出的能量驱动-分组协作机制通过**统一能量模型**与**分组差异化搜索**实现了探索-开发的动态平衡。理论分析与复杂度推导为算法有效性提供了支撑；伪代码与参数建议为工程实现提供了指导。未来可在以下方向继续深化：

1. **多智能体并行化**：结合分布式 RL 提升大规模实例求解效率。
2. **自适应混沌参数**：引入元学习自动调整混沌映射参数，增强泛化能力。
3. **理论收敛证明**：基于随机过程与演化算子，给出更严格的收敛速率界。

---

## 参考文献

[1] Heidari A. A., Mirjalili S., Faris H., *et al.* (2019). Harris Hawks Optimization: Algorithm and Applications. *FGCS*, 97, 849-872.  
[2] Mnih V., Kavukcuoglu K., Silver D., *et al.* (2015). Human-level Control Through Deep Reinforcement Learning. *Nature*, 518, 529-533.  
[3] Qin Y., Hao J., Prucho R., *et al.* (2023). Chaotic Map-Based Hybrid Metaheuristic for Multi-objective Scheduling. *IEEE T-EC*, 27(4), 600-613.  
[4] Watkins C. J. C. H., Dayan P. (1992). Q-learning. *Machine Learning*, 8, 279-292. 